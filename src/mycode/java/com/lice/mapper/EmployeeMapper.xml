<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE mapper
        PUBLIC "-//mybatis.org//DTD Mapper 3.0//EN"
        "http://mybatis.org/dtd/mybatis-3-mapper.dtd">
<!--
Mapper.xml中几个最流行的标签
cache –给定名称空间的缓存配置。
cache-ref –从另一个名称空间引用缓存配置。
resultMap –最复杂，功能最强大的元素，它描述如何从数据库结果集中加载对象。
parameterMap –已弃用！老式的参数映射方式。最好使用内联参数，以后可以删除此元素。此处未记录。
sql –可重用的SQL块，可以由其他语句引用。
insert –映射的INSERT语句。
update –映射的UPDATE语句。
delete –映射的DELETE语句。
select –映射的SELECT语句。

-->
<!--mapper namespace:指定Mapper的接口，映射Mapper接口中的方法和XML文件的执行的id的SQL语句-->
<mapper namespace="com.lice.mapper.EmployeeMapper">

    <!--resultMap：用于pojo实体和数据库表中的列进行映射,特别是在查询时，返回结果集时可以自动映射结果到相应的实体中-->
    <!--这样的一个 JavaBean 可以被映射到 ResultSet，就像映射到 HashMap 一样简单。-->
    <!--id:该resultMap的唯一标识，给select、insert、update、delete标签引用-->
    <!--type：数据库表中列名映射的pojo实体属性名称，可以使用别名机制，不使用别名机制则需要实体类的全限类名-->
    <resultMap id="employeeMap" type="employee">
        <!--表中唯一的id,即主键-->
        <id column="emp_id" property="empId"/>
        <!--表中其他列名和pojo实体属性名称映射-->
        <!--非主键列：column：为表列名或列的别名；property：为pojo的属性名称-->
        <result column="emp_name" property="empName"/>
        <result column="emp_no" property="empNo"/>
        <!--jdbcType:JDBC数据类型-->
        <result column="emp_birthday" property="empBirthday" jdbcType="TIMESTAMP"/>
        <result column="dep_no" property="depNo"/>
        <!--图片处理大字段处理，BLOB：二进制-->
        <!--        <result column="head_img" property="headImg" jdbcType="BLOB"/>-->
    </resultMap>

    <!-- select标签
        <select
                id="selectPerson"                与Mapper接口中的具体方法名称一致
                parameterType="int"              参数类型，就是参数查询的数据类型
                parameterMap="deprecated"        过时，参数Map
                resultType="hashmap"             结果集类型，从该语句返回的预期类型的​​标准类名或别名。请注意，对于集合，这应该是集合包含的类型，而不是集合本身的类型。使用resultType或 resultMap，不能两者都使用。
                resultMap="personResultMap"      对外部resultMap的命名引用。结果映射是MyBatis的最强大功能，并且对它们有很好的了解，可以解决许多困难的映射情况。使用resultMap或resultType，不能同时使用。
                flushCache="false"               将此设置为true会在调用此语句时刷新本地和第二级缓存。默认值：对于select语句为false。
                useCache="true"                  将其设置为true将导致该语句的结果被缓存在2级缓存中。默认值： 对于select语句为true。
                timeout="10"                     这设置了驱动程序在引发异常之前等待数据库从请求返回的秒数。默认为未设置（取决于驱动程序）
                fetchSize="256"                  这是一个驱动程序提示，将试图使驱动程序返回成批的行结果，这些行的大小等于此设置。默认为未设置（取决于驱动程序）
                statementType="PREPARED"         任何一个STATEMENT，PREPARED或CALLABLE。这使MyBatis分别使用Statement， PreparedStatement或CallableStatement。默认值：PREPARED。
                resultSetType="FORWARD_ONLY">    结果集类型
        </select>
    -->
    <!--resultType:指sqL语句执行后返回的数据类型为employee实体类，该处使用了别名机制-->
    <!--可以省略parameterType-->
    <select id="getEmployeeById" resultType="employee">
    		select
    			emp_id as empId,
    			emp_name as empName,
    			emp_no as empNO,
    			emp_birthday as empBirthday,
    			dep_no as depNo
    		 from tb_employee where emp_id = #{empId}
    </select>
    <select id="selectAll" resultMap="employeeMap">
        select * from tb_employee;
    </select>

    <!--    使用resultMap-->
    <!--可以忽略parameterType-->
    <!--    <select id="getEmployeeById" parameterType="java.lang.Integer" resultMap="employeeMap">-->
    <!--        select emp_id,emp_name,emp_no,emp_birthday from tb_employee where emp_id = #{empId}-->
    <!--    </select>-->

    <insert id="insertEmployee">
		insert into tb_employee(emp_id,emp_name,emp_no,emp_birthday)
		values(#{empId}, #{empName}, #{empNO}, #{empBirthday})
	</insert>


    <!--insert标签：
    <insert
            id="insertAuthor"
            parameterType="domain.blog.Author"
            flushCache="true"
            statementType="PREPARED"
            keyProperty=""
            keyColumn=""                        （仅插入和更新）使用生成的键设置表中的列名称。仅当键列不是表中的第一列时，才在某些数据库（如PostgreSQL）中需要这样做。如果需要多个生成的列，则可以是用逗号分隔的列名称列表。
            useGeneratedKeys=""                 仅插入和更新）这告诉MyBatis使用JDBC getGeneratedKeys方法检索数据库内部生成的密钥（例如，RDBMS中的自动增量字段，例如MySQL或SQL Server）。默认值：false
            timeout="20">
    </insert>


    注意：在insert时，一般会涉及新增记录，返回主键值，然后拿返回主键值做其他处理。
          但前提是数据库表主键是自动增加的， auto-generated keys.
     有种方式可以主键返回：
     1、JDBC方式返回主键自增的值（只支持主键自增数据库）
        <insert useGeneratedKeys="true" keyProperty="id"></insert>
        useGenerateKeys设置为true后， MyBatis会使用JDBC的getGeneratedKeys方法来取出由数据库内部生成的主键。
         获得主键值后将其赋值给keyProperty配置的id属性。当需要设置多个属性时，使用逗号隔开， 这种情况下通还需要设置keyColumn属性，
         按顺序指定数据库的列，这里列的值会和keyProperty配置的属性一一对应。然后可直接操作实体属性获取即可

    2、使用<selectKey>标签返回自增主键值（即适合主键自增的数据库，也适合主键不自增的数据库，如Oracle）
       如果不支持自增主键， 而是使用序列得到一个值，然后将这个值赋给id，再将数据插入数据库。

       <selectKey keyColumn="id" resultType="long" keyProperty="id" order="AFTER">
            select LAST_INSERT_ID()
       </selectKey>

       resultType:主键值返回的数据类型
       keyColumn和keyProperty上面的useGeneratedKeys功能一样
       keyColumn：表的id列名
       keyProperty：与列对应的实体属性名
       order：与使用的数据库有关，
               mysql：在MySQL数据库中，order属性设置的值是AFTER，因为当前记录的主键值在insert语句执行成功后才能获取到。
               Oracle：在Oracle数据库中，order的值要设置为BEFORE， 这是因为Oracle中需要先从序列获取值，然后将值作为主键插入到数据库中。

       LAST_INSERT_ID()：该函数是获取mysql数据库最后插入的数据ID值

       各大数据库使用获取主键返回值：
       Oracle： SELECT SEQ_ID.nextval from dual
       DB2 ： VALUES IDENTITY_VAL_LOCAL（）。
       MYSQL ： SELECT LAST_INSERT_ID（）。
       SQLSERVER ： SELECT SCOPE_IDENTITY（）。
       CLOUDSCAPE ：VALUES IDENTITY_VAL_LOCAL（）。
       DERBY ： VALUES IDENTITY_VAL_LOCAL（）。
       HSQLDB ： CALL IDENTITY（）。
       SYBASE ：SELECT@@ IDENTITY。
       DB2_MF ： SELECT IDENTITY_VAL_LOCAL（） FROM SYSIBM.SYSDUMMY1。
       INFORMIX ：select dbinfo（' sqlca.sqlerrd1'） from systables where tabid = 1。


    -->
    <!--update标签：
    <update
            id="updateAuthor"
            parameterType="domain.blog.Author"
            flushCache="true"
            statementType="PREPARED"
            timeout="20">
    </update>
    -->
    <update id="updateEmployee">

    </update>
    <!--
        foreach元素的属性主要有 item，index，collection，open，separator，close。
        item表示集合中每一个元素进行迭代时的别名，
        index指 定一个名字，用于表示在迭代过程中，每次迭代到的位置，
        open表示该语句以什么开始，
        separator表示在每次进行迭代之间以什么符号作为分隔符，
        close表示以什么结束。
        collection
            1. 如果传入的是单参数且参数类型是一个List的时候，collection属性值为list, parameterType="java.util.List"
            2. 如果传入的是单参数且参数类型是一个array数组的时候，collection的属性值为array, parameterType="java.util.ArrayList"
            3. 如果传入的参数是多个的时候，我们就需要把它们封装成一个Map了，当然单参数也可, parameterType="java.util.HashMap"
     -->
    <delete id="deleteEmployeeByIds" parameterType="java.util.ArrayList">
        delete from tb_employee where 1=1
        and emp_Id in
        <foreach collection="array" index="index" item="item" open="(" separator="," close=")">
            #{item}
        </foreach>
    </delete>

    <!--delete标签：
    <delete
            id="deleteAuthor"
            parameterType="domain.blog.Author"
            flushCache="true"
            statementType="PREPARED"
            timeout="20">
    </delete>
    -->


    <!--==================================mybatis的动态SQL==========================-->

    <!--
    Mybatis 3之后，采用了强大的OGNL表达式Object-Graph Navigation Language）来组成SQL动态语句的标签
    SQL在XML中支持的几种标签。
    · if
    · choose( when、 otherwise)
    · trim( where、 set)
    · foreach
    · bind
    -->


    <!--===========  if标签 =================-->
    <!--
    if标签：
    if标签通常用于where语句中，通过判断参数值来决定是否使用某个查询条件，
    也经常用于update语句中是否更新某一个字段值，
    还可以用于insert语句中判断是否插入某个字段值

    -->
    <!--
    用法：假设根据用户输入的条件进行查询员工表信息，
        1、当只输入员工名称时，根据员工名称进行模糊查询
        2、当输入员工号时，根据员工号进行模糊查询
        3、当同时输入员工名称和员工号时，用这两个条件进行查询
    -->

    <!--如果没有使用动态SQL时-->
    <select id="selectByEmpNameOrEmpNo" resultType="com.lice.pojo.Employee">
     select emp_id as empId,emp_name as empName,emp_no as empNo,emp_birthday as empBirthday
     , dep_no as depNo from tb_employee
     where emp_name like concat('%',#{empName},'%')
     and emp_no = #{empNo}

    </select>
    <!--以上当同时输入empName和empNo是可以正确查询的，但是当只输入empName时，导致empNo==null，将null也作为查询条件了，导致查询错误-->
    <!--使用if标签来解决这个问题-->
    <select id="selectByEmpNameOrEmpNo1" resultType="com.lice.pojo.Employee">
        select emp_id as empId,emp_name as empName,emp_no as empNo,emp_birthday as empBirthday
        , dep_no as depNo
        from tb_employee
        where 1=1
        <if test="empName != null and empName != ''">
            and emp_name like concat('%',#{empName},'%')
        </if>
        <if test="empNo !=null and empNo !=''">
            and emp_no = #{empNo}
        </if>

    </select>
    <!--
    if标签有一个必填的属性test，test的属性值是一个符合OGNL要求的判断表达式，表达式的结果可以是true或false，
    除此之外所有的非0值都为true， 只有0为false。 建议只用true或false作为结果。

    test中的属性值：
    ·判断条件 property!=null或 property== null： 适用于任何类型的字段，用于判断属性值是否为空。
    ·判断条件property!=''或property ==''：仅适用于String类型的字段，用于判断是否为空字符串。
    · and 和 or： 当有多个判断条件时，使用and或or进行连接，嵌套的判断可以使用小括号分组，and相当于Java中的与（&&），or相当于Java中的或（ ||）。
    上面两个条件的属性类型都是 String， 对字符串的判断和Java中的判断类似， 首先需要判断字段是否为null， 然后再去判断是否为空（在OGNL表达式中，这两个判断的顺序不会影响判断的结果，也不会有空指针异常）。

    注意：where关键字后面的条件 1==1，
    由于两个都是动态查询条件，如果没有默认的条件 1==1，一旦两个if判断都满足时，最后生成的SQL语句就是以where结束。
    这样就不符合SQL的语法规范了，就会报错，加上1==1,可以避免SQL语句的异常。

    但两个if不满足时：
    select emp_id,emp_name,emp_no,emp_birthday,dep_no from tb_employee where;(SQL语法错误)

    select emp_id,emp_name,emp_no,emp_birthday,dep_no from tb_employee where 1=1
    加上（1==1）时，尽管两个条件都不满足时，语法不会出异常，还是符合SQL语法规范的
    -->


    <!--if标签用于update-->
    <update id="updateEmployee">
        update tb_employee
        set
        <if test="empName !=null and empName != ''">
            emp_name = #{empName},
        </if>
        <if test="empNo !=null and empNo != ''">
            emp_no = #{empNo},
        </if>
        <if test="empBirthday !=null">
            emp_birthday = #{empBirthday,jdbcType=TIMESTAMP},
        </if>
        <if test="depNo !=null and depNo != ''">
            dep_no = #{depNo},
        </if>
        emp_id = #{empId} <!--保证SQL语法的正确-->
        where emp_id = #{empId}
    </update>
    <!--当全部条件都为null和""时
    update tb_employee set emp_id = #{empId} where emp_id = #{empId}

    如果没有 emp_id = #{empId}，尽管有一个条件满足的，也是SQL语法错误
    update tb_employee set emp_name = #{empName} ,(这里多个逗号) where emp_id =${empId}
    -->

    <!--if标签用于insert-->
    <insert id="insertEmployee" useGeneratedKeys="true" keyColumn="emp_id" keyProperty="empId">
        insert into tb_employee(
        <if test="empName != null and  empName !=''">
            emp_name,
        </if>
        emp_no,emp_birthday,dep_no)
        values(
        <if test="empName !=null and empName!=''">
            #{empName},
        </if>
        #{empNo},#{empBirthday},#{depNo}
        )
    </insert>
    <!--
    使用if标签中进行insert需要注意：
    若在列的部分增加if条件，则values的部分也要增加相同的if条件，必须保证上下可以互相对应，完全匹配。
    -->


    <!--===========  choose标签 =================-->
    <!--
    上面使用了if标签，if标签作用是判断，if标签逻辑只有if判断，却没有if-else逻辑判断。
    <choose>标签正式解决if标签没有if-else判断的，choose用于if-else判断和if-else-的.
    <choose>标签内嵌<when>和<otherwise>标签。
    choose 元素中包含when和otherwise两个标签，一个choose中至少有一个when，有0个或者1个otherwise。
    -->
    <select id="selectChoose" resultType="com.lice.pojo.Employee">
        select emp_id,emp_name,emp_no,emp_birthday,dep_no
        from tb_employee
        where 1==1
        <choose>
            <when test="empId !=null and empId!=''">
                and emp_id =#{empId},
            </when>
            <when test="empName !=null and empName !=''">
                and emp_name =#{empName}
            </when>
            <otherwise>
                1==2
            </otherwise>
        </choose>
        <!--如果满足第一个when，就是用第一个when作为查询条件；如果不满足继续往下判断第二个when；都不满足，则使用
            otherwise标签中条件
        -->
    </select>


    <!--===========  where、set、trim标签 =================-->

    <!--where标签-->
    <!--
    where标签：解决了上面where关键字后面使用if标签时需要添加 1==1的条件来确保SQL语法正确
    where标签的作用： 如果该标签包含的元素中有返回值，就插入一个where；如果where后面的字符串是以AND和OR开头的， 就将它们剔除。
    -->
    <select id="selectWhere" resultType="com.lice.pojo.Employee">
        select emp_id,emp_name,emp_no,emp_birthday,dep_no
        from tb_employee
        <where>
            <if test="empName !=null and empName!=''">
                and emp_name = #{empName},
            </if>
            <if test="empId !=null and empId!=''">
                and emp_id = #{empId},
            </if>
        </where>
        <!--
        当if标签中都不满足时，SQL语句中没有where关键字；
        如果一个if满足，则去掉开头的and关键字。
        如果两个都满足，则去掉第一个if中的and
        -->
    </select>


    <!--set标签-->
    <!--
    set标签作用是：解决update语句的set关键字
    -->
    <update id="updateSet">
        update tb_employee
        <set>
            <if test="empName !=null and empName != ''">
                emp_name = #{empName},
            </if>
            <if test="empNo !=null and empNo != ''">
                emp_no = #{empNo},
            </if>
            <if test="empBirthday !=null">
                emp_birthday = #{empBirthday,jdbcType=TIMESTAMP},
            </if>
            <if test="depNo !=null and depNo != ''">
                dep_no = #{depNo},
            </if>
            emp_id =#{empId}
        </set>
        where emp_id = #{empId}
    </update>



    <!--===========  foreach标签 =================-->






</mapper>